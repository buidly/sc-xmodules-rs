{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What are xModules ? \u00b6 Introduction \u00b6 xModules are an open-source library created by builders for builders with the scope of making smart contracts building a bit more modular on MultiversX ecosystem. Since the main SDK also provides a list of base modules that are used by the community, we felt that we can also contribute to this idea by making the community bring their components together and build a safer ecosystem. The idea behind \u00b6 Having smart contracts modules implemented, reviewed and used by the community gives us the power to have more trust in what code we write. We are bringing this idea of having community driven audited smart contract components and we want all of you builders out there to join us in expanding this. Not only for us or for you but for the ecosystem in general.","title":"Home"},{"location":"#what-are-xmodules-","text":"","title":"What are xModules ?"},{"location":"#introduction","text":"xModules are an open-source library created by builders for builders with the scope of making smart contracts building a bit more modular on MultiversX ecosystem. Since the main SDK also provides a list of base modules that are used by the community, we felt that we can also contribute to this idea by making the community bring their components together and build a safer ecosystem.","title":"Introduction"},{"location":"#the-idea-behind","text":"Having smart contracts modules implemented, reviewed and used by the community gives us the power to have more trust in what code we write. We are bringing this idea of having community driven audited smart contract components and we want all of you builders out there to join us in expanding this. Not only for us or for you but for the ecosystem in general.","title":"The idea behind"},{"location":"community/","text":"Contributing \u00b6 Welcome to the contributing guidelines for xModules ! We appreciate any and all contributions and are grateful for your efforts to improve our project. In order to streamline the contribution process and make it as easy as possible for you to help out, we have put together the following guidelines. Please take a moment to read through them before you begin. We welcome contributions in the form of: code documentation bug reports feature requests Note If you are unsure about something, please don\u2019t hesitate to ask. We are here to help and want to make sure that your contributions are accepted and merged as smoothly as possible. Thank you again for your interest in contributing to our project. We look forward to working with you! Bug Reports \u00b6 Found something that xModules should support? Stumbled upon some unexpected behavior? Possible bugs may be raised as a \u201cPotential Issue\u201d discussion, feature requests may be raised as an \u201cIdeas\u201d discussion. We can then determine if the discussion needs to be escalated into an \u201cIssue\u201d or not, or if we\u2019d consider a pull request. Try to be more descriptive as you can and in case of a bug report, provide as much information as possible like: mx-sdk version used Code snippet Error traceback You should always try to reduce any examples to the simplest possible case that demonstrates the issue. Implementing a new module \u00b6 For all the engineers and builders out there that what to implement a new module we assembled a detailed guide for you to follow. We start with the following steps: Step 1: Adding your code \u00b6 The first step is to implement a rust trait that defines the functions and storage your module will contain that will be added to a contract. For this example the name MyModule will be used to define the module we are trying to implement. Start by creating a new file inside the xmodules crate with the name my_module.rs and add it to the library root, meaning importing my_module.rs in lib.rs xmodules/src/lib.rs #![no_std] .. . pub mod my_module ; In my_module.rs implement the MyModule trait bt defined the trait with the module macro attribute to the trait #[elrond_wasm::module] xmodules/src/my_module.rs #[elrond_wasm::module] pub trait MyNewModule { .. . In this trait you add all the logic you want inside the module. Note Try as best you can to decouple it from other modules to overcome coupling and easily extending and implementing this module in other contracts. Step 2: Create tests \u00b6 For testing our modules we already implemented an empty contract with the full purpose of testing the modules inside the xmodules crate. This empty contract should not contain any logic but only inherit the modules traits. To start testing your module you first need to create a contract interaction file in order to have the functions for interacting with the logic you added in the module. Since we don\u2019t want to keep all the interactions from all the modules together we have separate test setup files inside the tests contract. In the tests/setup folder of the tests contract create a new file with the same name as the module you added in the xmodules crate. For this example this will be called setup/my_module.rs . Now import the base setup class TestsSetup and create a new implementation. tests/setup/my_module.rs /// Importing the base struct use super :: base :: TestsSetup ; /// Creating the implementation impl < Builder > TestsSetup < Builder > where Builder : ' static + Copy + Fn () -> tests :: ContractObj < DebugApi > { /// Add your contract interactions here } Add your contract interactions to this implementation and everything that is necessary for you to interact with the module. Note Check out the base struct for the base implementation that also contains some helper methods. Now that you created the contract interactions, you also need to create the tests. Create a new file in tests using the \u2018test\u2019 prefix and module name, in this case create the file tests/test_my_module.rs . In this file import the tests setup that will automatically include your contract interactions to use in the tests. tests/test_my_module.rs mod setup ; use setup :: TestsSetup ; #[test] fn test_my_module_one () { /// This is pretty standard for all tests as it initializes /// the base tests setup let mut setup = TestsSetup :: init ( tests :: contract_obj ); /// Add more logic to test your code } If you don\u2019t want to run the entire test suite you can always use the tests feature of cargo and specify which module to test cargo test --test test_my_module To run the entire test suite you can run cargo test after the test setup contract is built. Step 3. Create a PR to main \u00b6 From a separate branch using the prefix feat/my-module-implementation create a Pull Request to the main branch and be sure to add description and details about how your module works and why you think it can be beneficial inside the ecosystem. Tip Maybe throw some examples on were it can be used for other builders to understand this module role.","title":"Contributing"},{"location":"community/#contributing","text":"Welcome to the contributing guidelines for xModules ! We appreciate any and all contributions and are grateful for your efforts to improve our project. In order to streamline the contribution process and make it as easy as possible for you to help out, we have put together the following guidelines. Please take a moment to read through them before you begin. We welcome contributions in the form of: code documentation bug reports feature requests Note If you are unsure about something, please don\u2019t hesitate to ask. We are here to help and want to make sure that your contributions are accepted and merged as smoothly as possible. Thank you again for your interest in contributing to our project. We look forward to working with you!","title":"Contributing"},{"location":"community/#bug-reports","text":"Found something that xModules should support? Stumbled upon some unexpected behavior? Possible bugs may be raised as a \u201cPotential Issue\u201d discussion, feature requests may be raised as an \u201cIdeas\u201d discussion. We can then determine if the discussion needs to be escalated into an \u201cIssue\u201d or not, or if we\u2019d consider a pull request. Try to be more descriptive as you can and in case of a bug report, provide as much information as possible like: mx-sdk version used Code snippet Error traceback You should always try to reduce any examples to the simplest possible case that demonstrates the issue.","title":"Bug Reports"},{"location":"community/#implementing-a-new-module","text":"For all the engineers and builders out there that what to implement a new module we assembled a detailed guide for you to follow. We start with the following steps:","title":"Implementing a new module"},{"location":"community/#step-1-adding-your-code","text":"The first step is to implement a rust trait that defines the functions and storage your module will contain that will be added to a contract. For this example the name MyModule will be used to define the module we are trying to implement. Start by creating a new file inside the xmodules crate with the name my_module.rs and add it to the library root, meaning importing my_module.rs in lib.rs xmodules/src/lib.rs #![no_std] .. . pub mod my_module ; In my_module.rs implement the MyModule trait bt defined the trait with the module macro attribute to the trait #[elrond_wasm::module] xmodules/src/my_module.rs #[elrond_wasm::module] pub trait MyNewModule { .. . In this trait you add all the logic you want inside the module. Note Try as best you can to decouple it from other modules to overcome coupling and easily extending and implementing this module in other contracts.","title":"Step 1: Adding your code"},{"location":"community/#step-2-create-tests","text":"For testing our modules we already implemented an empty contract with the full purpose of testing the modules inside the xmodules crate. This empty contract should not contain any logic but only inherit the modules traits. To start testing your module you first need to create a contract interaction file in order to have the functions for interacting with the logic you added in the module. Since we don\u2019t want to keep all the interactions from all the modules together we have separate test setup files inside the tests contract. In the tests/setup folder of the tests contract create a new file with the same name as the module you added in the xmodules crate. For this example this will be called setup/my_module.rs . Now import the base setup class TestsSetup and create a new implementation. tests/setup/my_module.rs /// Importing the base struct use super :: base :: TestsSetup ; /// Creating the implementation impl < Builder > TestsSetup < Builder > where Builder : ' static + Copy + Fn () -> tests :: ContractObj < DebugApi > { /// Add your contract interactions here } Add your contract interactions to this implementation and everything that is necessary for you to interact with the module. Note Check out the base struct for the base implementation that also contains some helper methods. Now that you created the contract interactions, you also need to create the tests. Create a new file in tests using the \u2018test\u2019 prefix and module name, in this case create the file tests/test_my_module.rs . In this file import the tests setup that will automatically include your contract interactions to use in the tests. tests/test_my_module.rs mod setup ; use setup :: TestsSetup ; #[test] fn test_my_module_one () { /// This is pretty standard for all tests as it initializes /// the base tests setup let mut setup = TestsSetup :: init ( tests :: contract_obj ); /// Add more logic to test your code } If you don\u2019t want to run the entire test suite you can always use the tests feature of cargo and specify which module to test cargo test --test test_my_module To run the entire test suite you can run cargo test after the test setup contract is built.","title":"Step 2: Create tests"},{"location":"community/#step-3-create-a-pr-to-main","text":"From a separate branch using the prefix feat/my-module-implementation create a Pull Request to the main branch and be sure to add description and details about how your module works and why you think it can be beneficial inside the ecosystem. Tip Maybe throw some examples on were it can be used for other builders to understand this module role.","title":"Step 3. Create a PR to main"},{"location":"usage/","text":"Usage \u00b6 xModules is a library written in Rustlang that behaves like a crate. For all you entry level builders out there we will leave here a link to Rustlang documentation about crates/packages . Where to use xModules \u00b6 xModules will work under the umbrella of your contact, so the first step for this would be to have a base contract, that is also defined by a crate, and add as a dependency the xmodules crate as follows: your_contract/Cargo.toml # Please refer to the crates.io page for finding the latest version # https://crates.io/crates/xmodules [dependencies.xmodules] version = \"0.x.x\" How to add to your contract \u00b6 xModules can be a vast library of modules so please first check the library code to see which module you would like to use and its capabilities. Once you know which module to use simply import (or use ) the crate and module in the contract root and inherit it over the main contract. your_contract/lib.rs use xmodules :: my_module ; #[elrond_wasm::contract] pub trait MyContract : my_module :: MyModule { .. . Right now all the functions, storages and requires are added to your contract and can freely use it inside it as usual. Extending modules Beside using the modules directly on a contract, you can also extend another module by using any xmodule you find suitable for your case. use xmodules :: my_module ; #[elrond_wasm::module] pub trait MyContractModule : my_module :: MyModule { .. .","title":"Usage"},{"location":"usage/#usage","text":"xModules is a library written in Rustlang that behaves like a crate. For all you entry level builders out there we will leave here a link to Rustlang documentation about crates/packages .","title":"Usage"},{"location":"usage/#where-to-use-xmodules","text":"xModules will work under the umbrella of your contact, so the first step for this would be to have a base contract, that is also defined by a crate, and add as a dependency the xmodules crate as follows: your_contract/Cargo.toml # Please refer to the crates.io page for finding the latest version # https://crates.io/crates/xmodules [dependencies.xmodules] version = \"0.x.x\"","title":"Where to use xModules"},{"location":"usage/#how-to-add-to-your-contract","text":"xModules can be a vast library of modules so please first check the library code to see which module you would like to use and its capabilities. Once you know which module to use simply import (or use ) the crate and module in the contract root and inherit it over the main contract. your_contract/lib.rs use xmodules :: my_module ; #[elrond_wasm::contract] pub trait MyContract : my_module :: MyModule { .. . Right now all the functions, storages and requires are added to your contract and can freely use it inside it as usual. Extending modules Beside using the modules directly on a contract, you can also extend another module by using any xmodule you find suitable for your case. use xmodules :: my_module ; #[elrond_wasm::module] pub trait MyContractModule : my_module :: MyModule { .. .","title":"How to add to your contract"}]}